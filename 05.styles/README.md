Webpack by itself only knows javascript, so when we want it to pack any other type of resources like `.css` or `.scss`, webpack needs additional loaders to pack those types of files.

**css-loader** is the npm module that would help webpack to collect CSS from all the css files referenced in your application and put it into a string.

And then **style-loader** would take the output string generated by the above css-loader and put it inside the **&lt;style&gt;** tags in the **index.html** file.

Now that we have **css-loader** and **style-loader** added to webpack.config, it will work on any css that it finds in the dependency tree when it starts building the package starting from the entry file.

## For production

You can also get a Flash of Unstyled Content (FOUC). FOUC happens because the browser takes a while to load JavaScript and the styles would be applied only then. Separating CSS to a file of its own avoids the problem by letting the browser manage it separately.

Webpack provides a means to generate a separate CSS bundles using **mini-css-extract-plugin** (MCEP). It can aggregate multiple CSS files into one. For this reason, it comes with a loader that handles the extraction process. The plugin then picks up the result aggregated by the loader and emits a separate file.

Due to this process, **MiniCssExtractPlugin** comes with overhead during the compilation phase. It doesn't work with Hot Module Replacement (HMR) yet. Given the plugin is used only for production, that is not a problem.

**It can be potentially dangerous to use inline styles within JavaScript in production as it represents an attack vector. Critical path rendering embraces the idea and inlines the critical CSS to the initial HTML payload improving the perceived performance of the site. In limited contexts inlining a small amount of CSS can be a viable option to speed up the initial load (fewer requests).**
